#!/usr/bin/python
# -*- coding: UTF-8 -*-
from app.grab.up_calculate_strategy.historical_avg_of_last_month.XAVGUPOfLastMonthAbstractCalculateStrategy import XAVGUPOfLastMonthAbstractCalculateStrategy

class XAVGUPOfLastMonthDefaultCalculateStrategy(XAVGUPOfLastMonthAbstractCalculateStrategy):
    """

    -------------------------------------------------------------->>>> 算法
    historical_avg_unit_price_of_last_month

    读取历史数据，过去一个月历史该流向所有该品种的交易总价格，交易总重量，得到单价的变化区间及分布，选取出历史交易单价均值History Unit Price


    -----------------------------------------------------------------------------------------------------------------------------------------------
    -----------------------------------------------------------------------------------------------------------------------------------------------
    虚拟单价表db_inter.fictitious_unit_price
    需要提供，每个区对应八个大品种的单价信息，元每吨CNY/t，需要一个变化范围与均值（或最大分布）（小品种直接匹配?）



    -----------------------------------------------------------------------------------------------------------------------------------------------
    -----------------------------------------------------------------------------------------------------------------------------------------------
    虚拟车辆订单信息表（需要被抢的单子）
    需要按订单仓库形式提供，省市区，目的地，取货仓库，大品种，小品种，重量，类似于智能分货的输出，（取货地个数，卸货地个数）


    -----------------------------------------------------------------------------------------------------------------------------------------------
    -----------------------------------------------------------------------------------------------------------------------------------------------
    开发服构建虚拟历史抢单表 db_inter.fictitious_snatch_bill_mark
    需要提供抢单成功的与流单的数据，包括流向（省市区），大品种，总价格，总重量，单价=总价格/总重量，抢单总时长，抢单的初始总价，抢单成功时的在线人数
    如果包含两个大品种则需要按照两个大品种的重量总价格记录为两条数据

    """

    def __init__(self, p_historical_avg_unit_price_of_last_month=None, p_theoryUPDefaultCalculateStrategy=None):
        """

        :param p_line:
        :param p_date:
        """
        super(XAVGUPOfLastMonthAbstractCalculateStrategy, self).__init__()
        pass

    def calculate(self):
        """

        :return:
        """
        return 1
